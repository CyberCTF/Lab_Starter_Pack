---
description: Node.js and Express code quality guardrails — syntax, linting, package.json validation, and error checking
globs: ["**/*.js", "**/package.json", "**/package-lock.json"]
alwaysApply: false
---

# Node.js/Express Code Quality Verification Protocol

## Core Principle

Your primary task processing includes a **mandatory final verification stage** that ensures all Node.js files (`.js`) and configuration files (`package.json`) in the project are correctly coded, syntactically valid, and free of errors. You are NOT to consider your overall task complete until this verification stage confirms that all Node.js code is error-free.

## Phase 1: Primary Task Execution

1. Address the user's main request as you normally would: perform analysis, make code changes, call tools, and run applications/tests in sub-terminals if the main task requires it.
2. Leverage your ability to read outputs/errors from these sub-terminals to make iterative fixes during _this_ primary phase.

## Phase 2: Mandatory Node.js Code Verification

**This phase is executed automatically after Phase 1 and is a strict, non-negotiable requirement.**

### Step 1: Identify All Node.js Files

1. Use file system tools to find all files with `.js` extension in the project workspace.
2. Create a comprehensive list of all Node.js files that need verification.
3. Check for `package.json` file (required for Node.js projects).

### Step 2: Package.json Validation

1. **Verify package.json exists and is valid:**

   - Check that `package.json` exists in the project root.
   - Validate JSON syntax using `node -e "JSON.parse(require('fs').readFileSync('package.json', 'utf8'))"`.
   - Verify required fields: `name`, `version`, `main` or `scripts`.
   - Check that all dependencies are properly declared.

2. **Check for Common package.json Errors:**
   - Invalid JSON syntax
   - Missing required fields
   - Incorrect dependency versions
   - Missing `package-lock.json` or `yarn.lock` (should exist for reproducible builds)
   - Circular dependencies
   - Missing or incorrect `engines` field

### Step 3: Syntax Validation

For each Node.js file identified:

1. **Check JavaScript Syntax:**

   - Use `node --check <file>` or `node -c <file>` to verify syntax (parse check).
   - Use `npm run lint` or `eslint` if available.
   - If syntax errors are found, you MUST fix them before proceeding.

2. **Report any syntax errors found:**
   - Document the file path and the specific error message.
   - Fix syntax errors immediately.

### Step 4: Linting and Code Quality Checks

For each Node.js file:

1. **Run Linters (if available):**

   - Try running `eslint`, `jshint`, `prettier --check`, or `standard` on the files if these tools are available in the environment.
   - If linters are not available, perform manual code review for:
     - Undefined variables
     - Unused imports/exports
     - Missing imports
     - Syntax inconsistencies
     - Missing semicolons (if project style requires them)
     - Incorrect bracket/parentheses matching
     - Unused variables or functions

2. **Check for Common Errors:**
   - Undefined variables or properties
   - Missing required imports (`require`, `import`)
   - Circular dependency issues
   - Missing semicolons (if project style requires them)
   - Missing parentheses, brackets, or quotes
   - SQL injection vulnerabilities (if database queries are present)
   - XSS vulnerabilities (if output is not properly escaped)
   - Uninitialized variables (especially in strict mode)
   - Hoisting issues
   - Missing error handling in async functions

### Step 5: Dependency Verification

1. **Check Dependencies:**

   - Verify that all `require()` or `import` statements reference packages that exist in `package.json` dependencies.
   - Check that `node_modules` directory exists (or can be created with `npm install`).
   - Verify that all dependencies are properly installed.
   - Check for missing peer dependencies.

2. **Verify Module Resolution:**
   - Check that CommonJS (`require`) or ES modules (`import`) are used consistently.
   - Verify module paths are correct (relative or absolute).
   - Check for missing or incorrect module exports.

### Step 6: Express-Specific Checks (if Express is used)

1. **Express Configuration:**
   - Verify Express is properly imported and initialized.
   - Check that routes are properly defined.
   - Verify middleware is properly configured.
   - Check for security middleware (helmet, cors, etc.).

2. **Route Handling:**
   - Verify all routes have proper error handling.
   - Check that async route handlers use proper error handling.
   - Verify request/response handling is correct.

### Step 7: Runtime Error Detection

1. **Import/Require Verification:**

   - For each Node.js file, verify that all `require`, `import`, `import type`, and `export` statements reference files that exist and are accessible.
   - Check that all imported/required files exist and are properly referenced (relative or absolute paths).
   - Verify that module resolution works correctly (CommonJS, ES modules).
   - Verify that package dependencies are properly declared in `package.json`.

2. **Basic Execution Check (where applicable):**
   - For scripts that can be executed safely, perform a dry-run or minimal execution check using `node --check`.
   - Verify that the code can at least be parsed and initialized without fatal errors.
   - Check for undefined constants, functions, classes, or modules that would cause runtime errors.
   - Verify that all used Node.js globals are available (e.g., `process`, `Buffer`, `__dirname`, `__filename`).

### Step 8: Error Resolution Loop

1. **If errors are found:**

   - Document each error clearly (file path, line number if available, error type, error message).
   - Fix each error systematically.
   - Re-run verification after each fix.
   - Continue until all errors are resolved.

2. **Iterative Process:**
   - After fixing errors, re-run Steps 2-7 to ensure no new errors were introduced.
   - Continue this loop until verification passes completely.

## Phase 3: Task Completion Criteria

**The task is considered complete ONLY when:**

1. ✅ All Node.js files have been identified and verified.
2. ✅ `package.json` exists and is valid JSON.
3. ✅ No syntax errors exist in any Node.js file.
4. ✅ No linting errors or warnings exist (or all critical issues have been resolved).
5. ✅ All imports/requires are resolvable and valid.
6. ✅ No undefined variables or names are detected.
7. ✅ All dependencies are properly declared in `package.json`.
8. ✅ All code passes basic static analysis checks.
9. ✅ Express configuration is correct (if Express is used).
10. ✅ All routes have proper error handling (if Express is used).

**If any of these criteria are not met, the task is NOT complete, and you MUST continue fixing issues until all criteria are satisfied.**

## Final Verification Report

Before concluding, provide a summary report:

- **Total Node.js files checked:** [number]
- **package.json status:** ✅ Valid / ❌ Invalid
- **Files with errors found:** [number] (must be 0)
- **Dependencies status:** ✅ All resolved / ❌ Missing dependencies
- **Linting status:** ✅ Passed / ❌ Failed
- **Errors fixed:** [list of fixes made]
- **Final status:** ✅ All Node.js code is error-free and correctly coded

## Overriding Default Behavior

This entire "Node.js Code Verification" process (Phase 2 and Phase 3) is a **strict, non-negotiable requirement** that overrides any default tendency you have to end the conversation after completing Phase 1. The task is only finished when all Node.js code verification checks pass without errors. Your "sense of completion" for the original request is deferred until this verification phase confirms zero errors.
