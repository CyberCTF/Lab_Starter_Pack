---
description: Implement the entire lab inside /build with realistic app + single vulnerability; follow structure below
globs: ["**/build/**"]
alwaysApply: true
---

# Lab Development and Directory Structure for Build Folder

You are a senior web developer tasked with creating a complete lab directly in the `/build` folder based on provided files.

Your goal is to **analyze** the template folder, detect the technology stack, adapt to its conventions, and fully implement the scenario as a realistic business application with one vulnerability realistic **directly within the build directory structure**.

## Directory Naming Convention

The lab directory should have a name that clearly identifies the vulnerability type and is appropriate for the specific vulnerability being demonstrated.

### Examples

- `sql-injection-basic`
- `xss-stored-payload`
- `file-upload-rce`
- `xxe-internal-entities`
- `ssrf-localhost-bypass`
- `ldap-injection-auth-bypass`

### Directory Structure for Build Folder

```
tests/
docker-compose.yml
build/
│
├── docker-compose.dev.yml
├── web/ (or other service type)
│   ├── Dockerfile
│   └── src/ (application code)
├── .github/
│   └── workflows/
│       └── publish.yml
└── config/ (configuration files)
```

### Requirements for Build Folder Structure

- All lab components must be created directly within the `/build` directory
- Service directories (web, api, database) should be created as subdirectories of `/build`
- Configuration files should be placed at the root of `/build` or in a dedicated `config/` subdirectory
- Must be descriptive of the vulnerability being demonstrated
- Should be easily searchable and identifiable
- Must follow kebab-case convention for service names

## Development Best Practices

### Code Organization

- **Separation of Concerns**: Keep application logic separate from vulnerability code
- **Modular Design**: Use clear module boundaries
- **Configuration Management**: Externalize configuration settings
- **Error Handling**: Implement proper error handling without revealing sensitive information

### Security Considerations

- **Realistic Vulnerabilities**: Create vulnerabilities that mirror real-world scenarios
- **No Obvious Indicators**: Avoid making vulnerabilities too obvious
- **Professional Appearance**: Maintain realistic business application appearance
- **Data Sanitization**: Implement proper input validation where appropriate

### Application Architecture

- **Technology Stack**: Choose appropriate technologies for the vulnerability type
- **Database Design**: Create realistic database schemas
- **API Design**: Implement RESTful APIs where applicable
- **Frontend Integration**: Create professional-looking user interfaces

### File Organization for Build Folder

- **Source Code**: Place application code in service-specific directories (e.g., `web/src/`, `api/src/`)
- **Configuration**: Keep config files at the root of `/build` or in `config/` subdirectory
- **Docker Files**: Place Dockerfiles in their respective service directories
- **Docker Compose**: Keep docker-compose files at the root of `/build`

### Directory Creation Strategy

- **Direct Implementation**: Create all lab components directly within the `/build` directory
- **Service Isolation**: Each service (web, database, api) should have its own subdirectory
- **Flat Structure**: Avoid nested build directories - keep the structure flat and accessible

### Service Organization

- **Web Services**: Create in `/build/web/` with Dockerfile and source code
- **Database Services**: Create in `/build/database/` with initialization scripts
- **API Services**: Create in `/build/api/` with endpoint implementations
- **Configuration**: Centralize in `/build/config/` or at root level

### Development Workflow

1. **Analyze Template**: Understand the existing structure and technology stack
2. **Create Services**: Build each service component in its respective directory
3. **Configure Integration**: Set up docker-compose for service orchestration
4. **Implement Vulnerability**: Add realistic security flaws within the application logic
5. **Create Walkthrough**: Document exploitation path for maintainers/instructors (NOT player-facing)

## Maintainer Walkthrough Documentation

### Purpose

Create a walkthrough file for maintainers, instructors, and testing purposes. This file is **NOT player-facing** and should be placed in the `.ctf/` directory alongside other generation artifacts.

### Location

- **File Path**: `.ctf/WALKTHROUGH.md`
- **Directory**: Same level as `SCENARIO.md` and `FLAG.md`
- **Visibility**: Internal/maintainer documentation only (not included in player-facing README)

### Walkthrough Content Requirements

The walkthrough should include:

#### 1. Vulnerability Overview

- Brief description of the vulnerability type
- Location/component where the vulnerability exists
- Why it exists (realistic scenario context)

#### 2. Exploitation Steps

- Step-by-step exploitation path
- Required tools/techniques
- Payloads or attack vectors used
- Expected responses at each step

#### 3. Flag Extraction

- Exact method to extract the flag
- Database queries, file paths, API endpoints, or other extraction methods
- Expected flag format and location
- Validation that the extracted data matches the flag definition in `FLAG.md`

#### 4. Testing and Validation

- How to verify the vulnerability works
- How to test the exploitation path
- Expected results and outputs
- Common issues and troubleshooting

#### 5. Security Context

- Business impact of successful exploitation
- What the flag represents (admin credentials, sensitive data, etc.)
- Alignment with the scenario's crown jewels

### Walkthrough Structure Example

```markdown
# Vulnerability Walkthrough

## Vulnerability Type

[SQL Injection / XSS / File Upload / etc.]

## Location

[Specific file/endpoint/component where vulnerability exists]

## Exploitation Steps

### Step 1: [Initial Discovery]

- Action: [What to do]
- Expected Result: [What should happen]

### Step 2: [Vulnerability Identification]

- Action: [Test payload or method]
- Expected Result: [Response indicating vulnerability]

### Step 3: [Exploitation]

- Action: [Actual exploit payload]
- Expected Result: [Successful exploitation outcome]

### Step 4: [Flag Extraction]

- Action: [How to extract the flag]
- Expected Result: [Flag value/data]

## Flag Validation

- Expected Flag: [Value or location from FLAG.md]
- Extraction Method: [Database query / file read / API call / etc.]
- Validation: [How to verify the extracted data matches the flag]

## Testing Notes

[Additional information for maintainers to test the lab]
```

### Important Constraints

- **NOT Player-Facing**: This walkthrough must NOT be referenced in player-facing documentation (README.md, UI, etc.)
- **Maintainer Use Only**: Intended for lab creators, reviewers, and instructors
- **Detailed Enough**: Should enable a maintainer to reproduce the exploitation without guessing
- **Matches FLAG.md**: The extraction method must align with the flag definition in `.ctf/FLAG.md`
- **No Spoilers in Player Docs**: Ensure README.md and other player-facing content do not reference this walkthrough
